<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fire2a-lib.src.fire2a.managedata API documentation</title>
<meta name="description" content="Previous Read Data Prometheus" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fire2a-lib.src.fire2a.managedata</code></h1>
</header>
<section id="section-intro">
<p>Previous Read Data Prometheus</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!python3
&#34;&#34;&#34;
Previous Read Data Prometheus
&#34;&#34;&#34;
__author__ = &#34;David Palacios Meneses&#34;
__version__ = &#39;v0.0.1+0-gf866f08&#39;

from numpy import max as npmax
from numpy import empty as npempty
from numpy import full as npfull
from numpy import nan as npnan
from numpy import zeros as npzeros
from pandas import DataFrame
from pathlib import Path

def Lookupdict(filename: str) -&gt; tuple[dict, dict]:
    &#34;&#34;&#34;
    Reads lookup_table.csv and creates dictionaries for the fuel types and cells&#39; colors

    Args:
        filename (str): Path to fuel model lookup_table.csv, format is XXX_lookup_table.csv, e.g: spain_lookup_table.csv

    Returns:
        dict [int,str]: Dictionary with fuel code number as key and fuel model name as value.
        dict [int,list [int,int,int,int]]: Dictionary with fuel code number as key and list of colors in rgb as value.
    &#34;&#34;&#34; #fmt:skip

    aux = 1
    file = open(filename, &#34;r&#34;) 
    row = {}
    colors = {} 
    all = {}
    
    # Read file and save colors and ftypes dictionaries
    for line in file: 
        if aux &gt; 1:
            aux +=1
            line = line.replace(&#34;-&#34;,&#34;&#34;)
            line = line.replace(&#34;\n&#34;,&#34;&#34;)
            line = line.replace(&#34;No&#34;,&#34;NF&#34;)
            line = line.split(&#34;,&#34;)
            
            if line[3][0:3] in [&#34;FM1&#34;]:
                row[line[0]] = line[3][0:4]
            elif line[3][0:3] in [&#34;Non&#34;, &#34;NFn&#34;]:
                row[line[0]] = &#34;NF&#34;
            else:    
                row[line[0]] = line[3][0:3]
                
            colors[line[0]] = (float(line[4]) / 255.0, 
                               float(line[5]) / 255.0,
                               float(line[6]) / 255.0,
                               1.0)
            all[line[0]] = line
    
        if aux == 1:
            aux +=1
            
    return row, colors


def ForestGrid(filename:str, Lookupdict:dict) -&gt; tuple[(list,list,int,int,list,list,int)]:

    &#34;&#34;&#34;
    Reads fuels.asc file and returns an array with all the cells, and grid dimension nxm

    Args:
        filename (str): Path to fuel fuel model in ascii format (fuels.asc).
        Lookupdict (int,str): Dictionary with fuel code number as key and fuel model name as value.

    Returns:
        list [int]: List of forest grid with fuel code number, where non fuel are represented as 0
        list [str]: List of forest grid with fuel code name, where non fuel are represented as NF.
        int: Number of rows of forest grid.
        int: Number of columns of forest grid.
        list [dict[str,list[int]]]: List of dictionaries that contains the neighbors of each cell in each compass rose direction
        list [list[int,int]]: List of lists that stores the x and y coordinate of each cell
        int: Size of cells in forest grid

        
    &#34;&#34;&#34;#fmt:skip

    AdjCells = []
    North = &#34;N&#34;
    South = &#34;S&#34;
    East = &#34;E&#34;
    West = &#34;W&#34;
    NorthEast = &#34;NE&#34;
    NorthWest = &#34;NW&#34;
    SouthEast = &#34;SE&#34;
    SouthWest = &#34;SW&#34;
    
    with open(filename, &#34;r&#34;) as f:
        filelines = f.readlines()

    line = filelines[4].replace(&#34;\n&#34;,&#34;&#34;)
    parts = line.split()
    
    if parts[0] != &#34;cellsize&#34;:
        print (&#34;line=&#34;,line)
        raise RuntimeError(&#34;Expected cellsize on line 5 of &#34;+ filename)
    cellsize = float(parts[1])
    
    cells = 0
    row = 1
    trows = 0 
    tcols = 0
    gridcell1 = []
    gridcell2 = []
    gridcell3 = []
    gridcell4 = []
    grid = []
    grid2 = []
    
    # Read the ASCII file with the grid structure
    for row in range(6, len(filelines)):
        line = filelines[row]
        line = line.replace(&#34;\n&#34;,&#34;&#34;)
        line = &#39; &#39;.join(line.split())
        line = line.split(&#34; &#34;)
        #print(line)
        
        
        for c in line: #range(0,len(line)-1):
            if c not in Lookupdict.keys():
                gridcell1.append(&#34;NF&#34;)
                gridcell2.append(&#34;NF&#34;)
                gridcell3.append(int(0))
                gridcell4.append(&#34;NF&#34;)
            else:
                gridcell1.append(c)
                gridcell2.append(Lookupdict[c])
                gridcell3.append(int(c))
                gridcell4.append(Lookupdict[c])
            tcols = npmax([tcols,len(line)])

        grid.append(gridcell1)
        grid2.append(gridcell2)
        gridcell1 = []
        gridcell2 = []
    
    # Adjacent list of dictionaries and Cells coordinates
    CoordCells = npempty([len(grid)*(tcols), 2]).astype(int)
    n = 1
    tcols += 1
    for r in range(0, len(grid)):
        for c in range(0, tcols - 1):
            #CoordCells.append([c,len(grid)-r-1])
            CoordCells[c + r*(tcols-1), 0] = c
            CoordCells[c + r*(tcols-1), 1] = len(grid)-r-1
            
            if len(grid) &gt;1:
                
                if r == 0:
                    if c == 0:
                        AdjCells.append({North:None,NorthEast:None,NorthWest:None, 
                                         South:[n+tcols-1], SouthEast:[n+tcols], 
                                         SouthWest:None, East:[n+1],West:None})
                        n+=1
                    if c == tcols-2:
                        AdjCells.append({North:None,NorthEast:None,NorthWest:None,
                                         South:[n+tcols-1],SouthEast:None,SouthWest:[n+tcols-2], 
                                         East:None, West:[n-1]})
                        n+=1
                    if c&gt;0 and c&lt;tcols-2:    
                        AdjCells.append({North:None,NorthEast:None,NorthWest:None,
                                         South:[n+tcols-1],SouthEast:[n+tcols], 
                                         SouthWest:[n+tcols-2], East:[n+1],West:[n-1]})
                        n+=1
                
                if r &gt; 0 and r &lt; len(grid)-1:
                    if c == 0:
                        AdjCells.append({North:[n-tcols+1], NorthEast:[n-tcols+2], NorthWest:None,
                                         South:[n+tcols-1], SouthEast:[n+tcols], SouthWest:None,
                                         East:[n+1], West:None})
                        n+=1
                    if c == tcols-2:
                        AdjCells.append({North:[n-tcols+1], NorthEast:None, NorthWest:[n-tcols],
                                         South:[n+tcols-1], SouthEast:None, SouthWest:[n+tcols-2],
                                         East:None, West:[n-1]})
                        n+=1
                    if c&gt;0 and c&lt;tcols-2:    
                        AdjCells.append({North:[n-tcols+1], NorthEast:[n-tcols+2], NorthWest:[n-tcols],
                                         South:[n+tcols-1], SouthEast:[n+tcols], SouthWest:[n+tcols-2],
                                         East:[n+1], West:[n-1]})
                        n+=1        
                
                if r == len(grid)-1:
                    if c == 0:
                        AdjCells.append({North:[n-tcols+1], NorthEast:[n-tcols+2], NorthWest:None,
                                         South:None, SouthEast:None, SouthWest:None,
                                         East:[n+1], West:None})
                        n+=1
                        
                    if c == tcols-2:
                        AdjCells.append({North:[n-tcols+1], NorthEast:None, NorthWest:[n-tcols],
                                         South:None, SouthEast:None, SouthWest:None,
                                         East:None, West:[n-1]})
                        n+=1
                        
                    if c&gt;0 and c&lt;tcols-2:    
                        AdjCells.append({North:[n-tcols+1], NorthEast:[n-tcols+2], NorthWest:[n-tcols],
                                         South:None, SouthEast:None,SouthWest:None,
                                         East:[n+1], West:[n-1]})
                        n+=1
            
            if len(grid)==1:
                if c == 0:
                    AdjCells.append({North:None, NorthEast:None, NorthWest:None,
                                     South:None, SouthEast:None, SouthWest:None,
                                     East:[n+1], West:None})
                    n+=1
                if c == tcols-2:
                    AdjCells.append({North:None, NorthEast:None, NorthWest:None,
                                     South:None, SouthEast:None, SouthWest:None,
                                     East:None,West:[n-1]})
                    n+=1
                if c&gt;0 and c&lt;tcols-2:    
                    AdjCells.append({North:None, NorthEast:None, NorthWest:None,
                                     South:None, SouthEast:None, SouthWest:None,
                                     East:[n+1], West:[n-1]})
                    n+=1
    
    
    return gridcell3, gridcell4, len(grid), tcols-1, AdjCells, CoordCells, cellsize



def DataGrids(InFolder:str, NCells:int) -&gt; tuple[(list,list, list, list, list, list, list,list,list)]:
    &#34;&#34;&#34;
    Reads *.asc files and returns an array per each ASCII file with the correspondant information per each cell. Currently supports 
    elevation, ascpect, slope, curing, canopy bulk density, crown base height, conifer percent dead fir, probability of ignition and foliar moisture content.

    Args:
        InFolder (str): Path to data folder.
        NCells (int): Number of cells in grid.

    Returns:
        list [float]: List of elevations of each cell
        list [float]: List of aspect of each cell
        list [float]: List of slope of each cell
        list [float]: List of curing degree of each cell
        list [float]: List of canopy bulk density of each cell
        list [float]: List of crown base height of each cell
        list [float]: List of conifer percent dead fir of each cell
        list [float]: List of ignition probability of each cell
        list [float]: List of foliar moisture content of each cell

        
    &#34;&#34;&#34;#fmt:skip
    p=Path(InFolder)
    filenames = [&#34;elevation.asc&#34;, &#34;saz.asc&#34;, &#34;slope.asc&#34;, &#34;cur.asc&#34;, &#34;cbd.asc&#34;, &#34;cbh.asc&#34;, &#34;ccf.asc&#34;,&#34;py.asc&#34;,&#34;fmc.asc&#34;]
    Elevation =  npfull(NCells, npnan)
    SAZ = npfull(NCells, npnan)
    PS = npfull(NCells, npnan)
    Curing = npfull(NCells, npnan)
    CBD = npfull(NCells, npnan)
    CBH = npfull(NCells, npnan)
    CCF = npfull(NCells, npnan)
    PY = npfull(NCells, npnan)
    FMC=npfull(NCells,npnan)
    
    for name in filenames:
        ff = p/name
        if ff.exists() == True:
            aux = 0
            with open(ff, &#34;r&#34;) as f:
                filelines = f.readlines()

                line = filelines[4].replace(&#34;\n&#34;,&#34;&#34;)
                parts = line.split()

                if parts[0] != &#34;cellsize&#34;:
                    print (&#34;line=&#34;,line)
                    raise RuntimeError(&#34;Expected cellsize on line 5 of &#34;+ ff)
                cellsize = float(parts[1])

                row = 1

                # Read the ASCII file with the grid structure
                for row in range(6, len(filelines)):
                    line = filelines[row]
                    line = line.replace(&#34;\n&#34;,&#34;&#34;)
                    line = &#39; &#39;.join(line.split())
                    line = line.split(&#34; &#34;)
                    #print(line)
                    
                    for c in line: 
                        if name == &#34;elevation.asc&#34;:
                            Elevation[aux] = float(c)
                            aux += 1
                        if name == &#34;saz.asc&#34;:
                            SAZ[aux] = float(c)
                            aux += 1
                        if name == &#34;slope.asc&#34;:
                            PS[aux] = float(c)
                            aux += 1
                        if name == &#34;cbd.asc&#34;:
                            CBD[aux] = float(c)
                            aux += 1
                        if name == &#34;cbh.asc&#34;:
                            CBH[aux] = float(c)
                            aux += 1
                        if name == &#34;ccf.asc&#34;:
                            CCF[aux] = float(c)
                            aux += 1
                        if name == &#34;curing.asc&#34;:
                            Curing[aux] = float(c)
                            aux += 1
                        if name == &#34;py.asc&#34;:
                            PY[aux] = float(c)
                            aux += 1
                        if name == &#34;fmc.asc&#34;:
                            FMC[aux] = float(c)
                            aux += 1

        else:
            print(&#34;   No&#34;, name, &#34;file, filling with NaN&#34;)
            
    return Elevation, SAZ, PS, Curing, CBD, CBH, CCF,PY,FMC



# Generates the Data.dat file (csv) from all data files (ready for the simulator)
def GenerateDat(GFuelType:list, GFuelTypeN:list, Elevation:list, PS:list, SAZ:list, Curing:list, CBD:list, CBH:list, CCF:list,PY:list,FMC:list, InFolder:str) -&gt; DataFrame:
    &#34;&#34;&#34;
    Reads forest information and generates Data.csv file

    Args:
        GFuelType (list [int]): List of forest grid with fuel code number, where non fuel are represented as 0
        GFuelTypeN (list [str]): List of forest grid with fuel code name, where non fuel are represented as NF.
        Elevation (list [float]): List of elevations of each cell
        PS (list [float]): List of slope of each cell
        SAZ (list [float]): List of aspect of each cell
        Curing (list [float]): List of curing degree of each cell
        CBD (list [float]): List of canopy bulk density of each cell
        CBH (list [float]): List of crown base height of each cell
        CCF (list [float]): List of conifer percent dead fir of each cell
        PY (list [float]): List of ignition probability of each cell
        FMC (list [float]): List of foliar moisture content of each cell
        InFolder (str): Path to data folder.

    Returns:

        Dataframe: Dataframe containing information of forest


        
    &#34;&#34;&#34;#fmt:skip
    p=Path(InFolder)
    # DF columns
    Columns = [&#34;fueltype&#34;, &#34;lat&#34;, &#34;lon&#34;, &#34;elev&#34;, &#34;ws&#34;, &#34;waz&#34;, &#34;ps&#34;, &#34;saz&#34;, &#34;cur&#34;, &#34;cbd&#34;, &#34;cbh&#34;, &#34;ccf&#34;,&#34;ftypeN&#34;,&#34;fmc&#34;,&#34;py&#34;]
    
    # Dataframe
    DF = DataFrame(columns=Columns)
    DF[&#34;fueltype&#34;] = [x for x in GFuelType]
    DF[&#34;elev&#34;] = Elevation
    DF[&#34;ps&#34;] = PS
    DF[&#34;saz&#34;] = SAZ
    DF[&#34;cbd&#34;] = CBD
    DF[&#34;cbh&#34;] = CBH
    DF[&#34;ccf&#34;] = CCF
    DF[&#34;py&#34;] = PY
    DF[&#34;fmc&#34;] = FMC
    DF[&#34;lat&#34;] = npzeros(len(GFuelType)) + 51.621244
    DF[&#34;lon&#34;] = npzeros(len(GFuelType)).astype(int) - 115.608378
    
    # Populate fuel type number 
    DF[&#34;ftypeN&#34;] = GFuelTypeN
    #print(np.asarray(GFuelTypeN).flatten())
    
    # Data File
    filename = p/&#34;Data.csv&#34;
    DF.to_csv(path_or_buf=filename, index=False, index_label=False, header=True)
    return DF


def GenDataFile(InFolder:str,Simulator:str)-&gt;None:
    &#34;&#34;&#34;
    Main function that reads information available in folder and generates Data.csv file

    Args:
        InFolder (str): Path to data folder.
        Simulator (str): Simulator version, currently only supports &#34;K&#34; (for kitral) and &#34;S&#34; (for Scott &amp; Burgan)

    Return:
        None

 
    &#34;&#34;&#34;#fmt:skip
    p=Path(InFolder)
    if Simulator==&#34;K&#34;:
        FBPlookup=p/&#34;kitral_lookup_table.csv&#34;
    elif Simulator==&#34;S&#34;:
        FBPlookup = p/&#34;spain_lookup_table.csv&#34;
    else: #beta version
        FBPlookup = p/&#34;spain_lookup_table.csv&#34;

    FBPDict, _ =  Lookupdict(FBPlookup)
    
    FGrid = p/&#34;fuels.asc&#34;
    GFuelTypeN, GFuelType,_,_,_,_,_= ForestGrid(FGrid, FBPDict)
    
    NCells = len(GFuelType)
    Elevation, SAZ, PS, Curing, CBD, CBH, CCF,PY,FMC = DataGrids(InFolder, NCells)
    GenerateDat(GFuelType, GFuelTypeN, Elevation, PS, SAZ, Curing, CBD, CBH, CCF,PY,FMC, InFolder)


if __name__==&#34;__main__&#34;:
    p=Path(&#34;tests&#34;)
    p_fuels=p/&#34;fuels.asc&#34;
    p_lookup=p/&#34;spain_lookup_table.csv&#34;
    GenDataFile(&#34;tests&#34;,&#34;S&#34;)
    #check if generate data exists</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fire2a-lib.src.fire2a.managedata.DataGrids"><code class="name flex">
<span>def <span class="ident">DataGrids</span></span>(<span>InFolder: str, NCells: int) ‑> tuple[list, list, list, list, list, list, list, list, list]</span>
</code></dt>
<dd>
<div class="desc"><p>Reads *.asc files and returns an array per each ASCII file with the correspondant information per each cell. Currently supports
elevation, ascpect, slope, curing, canopy bulk density, crown base height, conifer percent dead fir, probability of ignition and foliar moisture content.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>InFolder</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to data folder.</dd>
<dt><strong><code>NCells</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of cells in grid.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list [float]</code></dt>
<dd>List of elevations of each cell</dd>
<dt><code>list [float]</code></dt>
<dd>List of aspect of each cell</dd>
<dt><code>list [float]</code></dt>
<dd>List of slope of each cell</dd>
<dt><code>list [float]</code></dt>
<dd>List of curing degree of each cell</dd>
<dt><code>list [float]</code></dt>
<dd>List of canopy bulk density of each cell</dd>
<dt><code>list [float]</code></dt>
<dd>List of crown base height of each cell</dd>
<dt><code>list [float]</code></dt>
<dd>List of conifer percent dead fir of each cell</dd>
<dt><code>list [float]</code></dt>
<dd>List of ignition probability of each cell</dd>
<dt><code>list [float]</code></dt>
<dd>List of foliar moisture content of each cell</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DataGrids(InFolder:str, NCells:int) -&gt; tuple[(list,list, list, list, list, list, list,list,list)]:
    &#34;&#34;&#34;
    Reads *.asc files and returns an array per each ASCII file with the correspondant information per each cell. Currently supports 
    elevation, ascpect, slope, curing, canopy bulk density, crown base height, conifer percent dead fir, probability of ignition and foliar moisture content.

    Args:
        InFolder (str): Path to data folder.
        NCells (int): Number of cells in grid.

    Returns:
        list [float]: List of elevations of each cell
        list [float]: List of aspect of each cell
        list [float]: List of slope of each cell
        list [float]: List of curing degree of each cell
        list [float]: List of canopy bulk density of each cell
        list [float]: List of crown base height of each cell
        list [float]: List of conifer percent dead fir of each cell
        list [float]: List of ignition probability of each cell
        list [float]: List of foliar moisture content of each cell

        
    &#34;&#34;&#34;#fmt:skip
    p=Path(InFolder)
    filenames = [&#34;elevation.asc&#34;, &#34;saz.asc&#34;, &#34;slope.asc&#34;, &#34;cur.asc&#34;, &#34;cbd.asc&#34;, &#34;cbh.asc&#34;, &#34;ccf.asc&#34;,&#34;py.asc&#34;,&#34;fmc.asc&#34;]
    Elevation =  npfull(NCells, npnan)
    SAZ = npfull(NCells, npnan)
    PS = npfull(NCells, npnan)
    Curing = npfull(NCells, npnan)
    CBD = npfull(NCells, npnan)
    CBH = npfull(NCells, npnan)
    CCF = npfull(NCells, npnan)
    PY = npfull(NCells, npnan)
    FMC=npfull(NCells,npnan)
    
    for name in filenames:
        ff = p/name
        if ff.exists() == True:
            aux = 0
            with open(ff, &#34;r&#34;) as f:
                filelines = f.readlines()

                line = filelines[4].replace(&#34;\n&#34;,&#34;&#34;)
                parts = line.split()

                if parts[0] != &#34;cellsize&#34;:
                    print (&#34;line=&#34;,line)
                    raise RuntimeError(&#34;Expected cellsize on line 5 of &#34;+ ff)
                cellsize = float(parts[1])

                row = 1

                # Read the ASCII file with the grid structure
                for row in range(6, len(filelines)):
                    line = filelines[row]
                    line = line.replace(&#34;\n&#34;,&#34;&#34;)
                    line = &#39; &#39;.join(line.split())
                    line = line.split(&#34; &#34;)
                    #print(line)
                    
                    for c in line: 
                        if name == &#34;elevation.asc&#34;:
                            Elevation[aux] = float(c)
                            aux += 1
                        if name == &#34;saz.asc&#34;:
                            SAZ[aux] = float(c)
                            aux += 1
                        if name == &#34;slope.asc&#34;:
                            PS[aux] = float(c)
                            aux += 1
                        if name == &#34;cbd.asc&#34;:
                            CBD[aux] = float(c)
                            aux += 1
                        if name == &#34;cbh.asc&#34;:
                            CBH[aux] = float(c)
                            aux += 1
                        if name == &#34;ccf.asc&#34;:
                            CCF[aux] = float(c)
                            aux += 1
                        if name == &#34;curing.asc&#34;:
                            Curing[aux] = float(c)
                            aux += 1
                        if name == &#34;py.asc&#34;:
                            PY[aux] = float(c)
                            aux += 1
                        if name == &#34;fmc.asc&#34;:
                            FMC[aux] = float(c)
                            aux += 1

        else:
            print(&#34;   No&#34;, name, &#34;file, filling with NaN&#34;)
            
    return Elevation, SAZ, PS, Curing, CBD, CBH, CCF,PY,FMC</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.managedata.ForestGrid"><code class="name flex">
<span>def <span class="ident">ForestGrid</span></span>(<span>filename: str, Lookupdict: dict) ‑> tuple[list, list, int, int, list, list, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Reads fuels.asc file and returns an array with all the cells, and grid dimension nxm</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to fuel fuel model in ascii format (fuels.asc).</dd>
<dt><strong><code>Lookupdict</code></strong> :&ensp;<code>int,str</code></dt>
<dd>Dictionary with fuel code number as key and fuel model name as value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list [int]</code></dt>
<dd>List of forest grid with fuel code number, where non fuel are represented as 0</dd>
<dt><code>list [str]</code></dt>
<dd>List of forest grid with fuel code name, where non fuel are represented as NF.</dd>
<dt><code>int</code></dt>
<dd>Number of rows of forest grid.</dd>
<dt><code>int</code></dt>
<dd>Number of columns of forest grid.</dd>
<dt><code>list [dict[str,list[int]]]</code></dt>
<dd>List of dictionaries that contains the neighbors of each cell in each compass rose direction</dd>
<dt><code>list [list[int,int]]</code></dt>
<dd>List of lists that stores the x and y coordinate of each cell</dd>
<dt><code>int</code></dt>
<dd>Size of cells in forest grid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ForestGrid(filename:str, Lookupdict:dict) -&gt; tuple[(list,list,int,int,list,list,int)]:

    &#34;&#34;&#34;
    Reads fuels.asc file and returns an array with all the cells, and grid dimension nxm

    Args:
        filename (str): Path to fuel fuel model in ascii format (fuels.asc).
        Lookupdict (int,str): Dictionary with fuel code number as key and fuel model name as value.

    Returns:
        list [int]: List of forest grid with fuel code number, where non fuel are represented as 0
        list [str]: List of forest grid with fuel code name, where non fuel are represented as NF.
        int: Number of rows of forest grid.
        int: Number of columns of forest grid.
        list [dict[str,list[int]]]: List of dictionaries that contains the neighbors of each cell in each compass rose direction
        list [list[int,int]]: List of lists that stores the x and y coordinate of each cell
        int: Size of cells in forest grid

        
    &#34;&#34;&#34;#fmt:skip

    AdjCells = []
    North = &#34;N&#34;
    South = &#34;S&#34;
    East = &#34;E&#34;
    West = &#34;W&#34;
    NorthEast = &#34;NE&#34;
    NorthWest = &#34;NW&#34;
    SouthEast = &#34;SE&#34;
    SouthWest = &#34;SW&#34;
    
    with open(filename, &#34;r&#34;) as f:
        filelines = f.readlines()

    line = filelines[4].replace(&#34;\n&#34;,&#34;&#34;)
    parts = line.split()
    
    if parts[0] != &#34;cellsize&#34;:
        print (&#34;line=&#34;,line)
        raise RuntimeError(&#34;Expected cellsize on line 5 of &#34;+ filename)
    cellsize = float(parts[1])
    
    cells = 0
    row = 1
    trows = 0 
    tcols = 0
    gridcell1 = []
    gridcell2 = []
    gridcell3 = []
    gridcell4 = []
    grid = []
    grid2 = []
    
    # Read the ASCII file with the grid structure
    for row in range(6, len(filelines)):
        line = filelines[row]
        line = line.replace(&#34;\n&#34;,&#34;&#34;)
        line = &#39; &#39;.join(line.split())
        line = line.split(&#34; &#34;)
        #print(line)
        
        
        for c in line: #range(0,len(line)-1):
            if c not in Lookupdict.keys():
                gridcell1.append(&#34;NF&#34;)
                gridcell2.append(&#34;NF&#34;)
                gridcell3.append(int(0))
                gridcell4.append(&#34;NF&#34;)
            else:
                gridcell1.append(c)
                gridcell2.append(Lookupdict[c])
                gridcell3.append(int(c))
                gridcell4.append(Lookupdict[c])
            tcols = npmax([tcols,len(line)])

        grid.append(gridcell1)
        grid2.append(gridcell2)
        gridcell1 = []
        gridcell2 = []
    
    # Adjacent list of dictionaries and Cells coordinates
    CoordCells = npempty([len(grid)*(tcols), 2]).astype(int)
    n = 1
    tcols += 1
    for r in range(0, len(grid)):
        for c in range(0, tcols - 1):
            #CoordCells.append([c,len(grid)-r-1])
            CoordCells[c + r*(tcols-1), 0] = c
            CoordCells[c + r*(tcols-1), 1] = len(grid)-r-1
            
            if len(grid) &gt;1:
                
                if r == 0:
                    if c == 0:
                        AdjCells.append({North:None,NorthEast:None,NorthWest:None, 
                                         South:[n+tcols-1], SouthEast:[n+tcols], 
                                         SouthWest:None, East:[n+1],West:None})
                        n+=1
                    if c == tcols-2:
                        AdjCells.append({North:None,NorthEast:None,NorthWest:None,
                                         South:[n+tcols-1],SouthEast:None,SouthWest:[n+tcols-2], 
                                         East:None, West:[n-1]})
                        n+=1
                    if c&gt;0 and c&lt;tcols-2:    
                        AdjCells.append({North:None,NorthEast:None,NorthWest:None,
                                         South:[n+tcols-1],SouthEast:[n+tcols], 
                                         SouthWest:[n+tcols-2], East:[n+1],West:[n-1]})
                        n+=1
                
                if r &gt; 0 and r &lt; len(grid)-1:
                    if c == 0:
                        AdjCells.append({North:[n-tcols+1], NorthEast:[n-tcols+2], NorthWest:None,
                                         South:[n+tcols-1], SouthEast:[n+tcols], SouthWest:None,
                                         East:[n+1], West:None})
                        n+=1
                    if c == tcols-2:
                        AdjCells.append({North:[n-tcols+1], NorthEast:None, NorthWest:[n-tcols],
                                         South:[n+tcols-1], SouthEast:None, SouthWest:[n+tcols-2],
                                         East:None, West:[n-1]})
                        n+=1
                    if c&gt;0 and c&lt;tcols-2:    
                        AdjCells.append({North:[n-tcols+1], NorthEast:[n-tcols+2], NorthWest:[n-tcols],
                                         South:[n+tcols-1], SouthEast:[n+tcols], SouthWest:[n+tcols-2],
                                         East:[n+1], West:[n-1]})
                        n+=1        
                
                if r == len(grid)-1:
                    if c == 0:
                        AdjCells.append({North:[n-tcols+1], NorthEast:[n-tcols+2], NorthWest:None,
                                         South:None, SouthEast:None, SouthWest:None,
                                         East:[n+1], West:None})
                        n+=1
                        
                    if c == tcols-2:
                        AdjCells.append({North:[n-tcols+1], NorthEast:None, NorthWest:[n-tcols],
                                         South:None, SouthEast:None, SouthWest:None,
                                         East:None, West:[n-1]})
                        n+=1
                        
                    if c&gt;0 and c&lt;tcols-2:    
                        AdjCells.append({North:[n-tcols+1], NorthEast:[n-tcols+2], NorthWest:[n-tcols],
                                         South:None, SouthEast:None,SouthWest:None,
                                         East:[n+1], West:[n-1]})
                        n+=1
            
            if len(grid)==1:
                if c == 0:
                    AdjCells.append({North:None, NorthEast:None, NorthWest:None,
                                     South:None, SouthEast:None, SouthWest:None,
                                     East:[n+1], West:None})
                    n+=1
                if c == tcols-2:
                    AdjCells.append({North:None, NorthEast:None, NorthWest:None,
                                     South:None, SouthEast:None, SouthWest:None,
                                     East:None,West:[n-1]})
                    n+=1
                if c&gt;0 and c&lt;tcols-2:    
                    AdjCells.append({North:None, NorthEast:None, NorthWest:None,
                                     South:None, SouthEast:None, SouthWest:None,
                                     East:[n+1], West:[n-1]})
                    n+=1
    
    
    return gridcell3, gridcell4, len(grid), tcols-1, AdjCells, CoordCells, cellsize</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.managedata.GenDataFile"><code class="name flex">
<span>def <span class="ident">GenDataFile</span></span>(<span>InFolder: str, Simulator: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Main function that reads information available in folder and generates Data.csv file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>InFolder</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to data folder.</dd>
<dt><strong><code>Simulator</code></strong> :&ensp;<code>str</code></dt>
<dd>Simulator version, currently only supports "K" (for kitral) and "S" (for Scott &amp; Burgan)</dd>
</dl>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GenDataFile(InFolder:str,Simulator:str)-&gt;None:
    &#34;&#34;&#34;
    Main function that reads information available in folder and generates Data.csv file

    Args:
        InFolder (str): Path to data folder.
        Simulator (str): Simulator version, currently only supports &#34;K&#34; (for kitral) and &#34;S&#34; (for Scott &amp; Burgan)

    Return:
        None

 
    &#34;&#34;&#34;#fmt:skip
    p=Path(InFolder)
    if Simulator==&#34;K&#34;:
        FBPlookup=p/&#34;kitral_lookup_table.csv&#34;
    elif Simulator==&#34;S&#34;:
        FBPlookup = p/&#34;spain_lookup_table.csv&#34;
    else: #beta version
        FBPlookup = p/&#34;spain_lookup_table.csv&#34;

    FBPDict, _ =  Lookupdict(FBPlookup)
    
    FGrid = p/&#34;fuels.asc&#34;
    GFuelTypeN, GFuelType,_,_,_,_,_= ForestGrid(FGrid, FBPDict)
    
    NCells = len(GFuelType)
    Elevation, SAZ, PS, Curing, CBD, CBH, CCF,PY,FMC = DataGrids(InFolder, NCells)
    GenerateDat(GFuelType, GFuelTypeN, Elevation, PS, SAZ, Curing, CBD, CBH, CCF,PY,FMC, InFolder)</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.managedata.GenerateDat"><code class="name flex">
<span>def <span class="ident">GenerateDat</span></span>(<span>GFuelType: list, GFuelTypeN: list, Elevation: list, PS: list, SAZ: list, Curing: list, CBD: list, CBH: list, CCF: list, PY: list, FMC: list, InFolder: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Reads forest information and generates Data.csv file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>GFuelType</code></strong> :&ensp;<code>list [int]</code></dt>
<dd>List of forest grid with fuel code number, where non fuel are represented as 0</dd>
<dt><strong><code>GFuelTypeN</code></strong> :&ensp;<code>list [str]</code></dt>
<dd>List of forest grid with fuel code name, where non fuel are represented as NF.</dd>
<dt><strong><code>Elevation</code></strong> :&ensp;<code>list [float]</code></dt>
<dd>List of elevations of each cell</dd>
<dt><strong><code>PS</code></strong> :&ensp;<code>list [float]</code></dt>
<dd>List of slope of each cell</dd>
<dt><strong><code>SAZ</code></strong> :&ensp;<code>list [float]</code></dt>
<dd>List of aspect of each cell</dd>
<dt><strong><code>Curing</code></strong> :&ensp;<code>list [float]</code></dt>
<dd>List of curing degree of each cell</dd>
<dt><strong><code>CBD</code></strong> :&ensp;<code>list [float]</code></dt>
<dd>List of canopy bulk density of each cell</dd>
<dt><strong><code>CBH</code></strong> :&ensp;<code>list [float]</code></dt>
<dd>List of crown base height of each cell</dd>
<dt><strong><code>CCF</code></strong> :&ensp;<code>list [float]</code></dt>
<dd>List of conifer percent dead fir of each cell</dd>
<dt><strong><code>PY</code></strong> :&ensp;<code>list [float]</code></dt>
<dd>List of ignition probability of each cell</dd>
<dt><strong><code>FMC</code></strong> :&ensp;<code>list [float]</code></dt>
<dd>List of foliar moisture content of each cell</dd>
<dt><strong><code>InFolder</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to data folder.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dataframe</code></dt>
<dd>Dataframe containing information of forest</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GenerateDat(GFuelType:list, GFuelTypeN:list, Elevation:list, PS:list, SAZ:list, Curing:list, CBD:list, CBH:list, CCF:list,PY:list,FMC:list, InFolder:str) -&gt; DataFrame:
    &#34;&#34;&#34;
    Reads forest information and generates Data.csv file

    Args:
        GFuelType (list [int]): List of forest grid with fuel code number, where non fuel are represented as 0
        GFuelTypeN (list [str]): List of forest grid with fuel code name, where non fuel are represented as NF.
        Elevation (list [float]): List of elevations of each cell
        PS (list [float]): List of slope of each cell
        SAZ (list [float]): List of aspect of each cell
        Curing (list [float]): List of curing degree of each cell
        CBD (list [float]): List of canopy bulk density of each cell
        CBH (list [float]): List of crown base height of each cell
        CCF (list [float]): List of conifer percent dead fir of each cell
        PY (list [float]): List of ignition probability of each cell
        FMC (list [float]): List of foliar moisture content of each cell
        InFolder (str): Path to data folder.

    Returns:

        Dataframe: Dataframe containing information of forest


        
    &#34;&#34;&#34;#fmt:skip
    p=Path(InFolder)
    # DF columns
    Columns = [&#34;fueltype&#34;, &#34;lat&#34;, &#34;lon&#34;, &#34;elev&#34;, &#34;ws&#34;, &#34;waz&#34;, &#34;ps&#34;, &#34;saz&#34;, &#34;cur&#34;, &#34;cbd&#34;, &#34;cbh&#34;, &#34;ccf&#34;,&#34;ftypeN&#34;,&#34;fmc&#34;,&#34;py&#34;]
    
    # Dataframe
    DF = DataFrame(columns=Columns)
    DF[&#34;fueltype&#34;] = [x for x in GFuelType]
    DF[&#34;elev&#34;] = Elevation
    DF[&#34;ps&#34;] = PS
    DF[&#34;saz&#34;] = SAZ
    DF[&#34;cbd&#34;] = CBD
    DF[&#34;cbh&#34;] = CBH
    DF[&#34;ccf&#34;] = CCF
    DF[&#34;py&#34;] = PY
    DF[&#34;fmc&#34;] = FMC
    DF[&#34;lat&#34;] = npzeros(len(GFuelType)) + 51.621244
    DF[&#34;lon&#34;] = npzeros(len(GFuelType)).astype(int) - 115.608378
    
    # Populate fuel type number 
    DF[&#34;ftypeN&#34;] = GFuelTypeN
    #print(np.asarray(GFuelTypeN).flatten())
    
    # Data File
    filename = p/&#34;Data.csv&#34;
    DF.to_csv(path_or_buf=filename, index=False, index_label=False, header=True)
    return DF</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.managedata.Lookupdict"><code class="name flex">
<span>def <span class="ident">Lookupdict</span></span>(<span>filename: str) ‑> tuple[dict, dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Reads lookup_table.csv and creates dictionaries for the fuel types and cells' colors</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to fuel model lookup_table.csv, format is XXX_lookup_table.csv, e.g: spain_lookup_table.csv</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict [int,str]</code></dt>
<dd>Dictionary with fuel code number as key and fuel model name as value.</dd>
<dt><code>dict [int,list [int,int,int,int]]</code></dt>
<dd>Dictionary with fuel code number as key and list of colors in rgb as value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Lookupdict(filename: str) -&gt; tuple[dict, dict]:
    &#34;&#34;&#34;
    Reads lookup_table.csv and creates dictionaries for the fuel types and cells&#39; colors

    Args:
        filename (str): Path to fuel model lookup_table.csv, format is XXX_lookup_table.csv, e.g: spain_lookup_table.csv

    Returns:
        dict [int,str]: Dictionary with fuel code number as key and fuel model name as value.
        dict [int,list [int,int,int,int]]: Dictionary with fuel code number as key and list of colors in rgb as value.
    &#34;&#34;&#34; #fmt:skip

    aux = 1
    file = open(filename, &#34;r&#34;) 
    row = {}
    colors = {} 
    all = {}
    
    # Read file and save colors and ftypes dictionaries
    for line in file: 
        if aux &gt; 1:
            aux +=1
            line = line.replace(&#34;-&#34;,&#34;&#34;)
            line = line.replace(&#34;\n&#34;,&#34;&#34;)
            line = line.replace(&#34;No&#34;,&#34;NF&#34;)
            line = line.split(&#34;,&#34;)
            
            if line[3][0:3] in [&#34;FM1&#34;]:
                row[line[0]] = line[3][0:4]
            elif line[3][0:3] in [&#34;Non&#34;, &#34;NFn&#34;]:
                row[line[0]] = &#34;NF&#34;
            else:    
                row[line[0]] = line[3][0:3]
                
            colors[line[0]] = (float(line[4]) / 255.0, 
                               float(line[5]) / 255.0,
                               float(line[6]) / 255.0,
                               1.0)
            all[line[0]] = line
    
        if aux == 1:
            aux +=1
            
    return row, colors</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fire2a-lib.src.fire2a" href="index.html">fire2a-lib.src.fire2a</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fire2a-lib.src.fire2a.managedata.DataGrids" href="#fire2a-lib.src.fire2a.managedata.DataGrids">DataGrids</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.managedata.ForestGrid" href="#fire2a-lib.src.fire2a.managedata.ForestGrid">ForestGrid</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.managedata.GenDataFile" href="#fire2a-lib.src.fire2a.managedata.GenDataFile">GenDataFile</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.managedata.GenerateDat" href="#fire2a-lib.src.fire2a.managedata.GenerateDat">GenerateDat</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.managedata.Lookupdict" href="#fire2a-lib.src.fire2a.managedata.Lookupdict">Lookupdict</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>